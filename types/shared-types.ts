import type Mux from '@mux/mux-node';
import { z } from 'zod';
import { storedTextTrackToMuxTrack } from '../server/src/utils/text-tracks';

export const SUPPORTED_MUX_LANGUAGES = [
  { label: 'English', code: 'en', state: 'Stable' },
  { label: 'Spanish', code: 'es', state: 'Stable' },
  { label: 'Italian', code: 'it', state: 'Stable' },
  { label: 'Portuguese', code: 'pt', state: 'Stable' },
  { label: 'German', code: 'de', state: 'Stable' },
  { label: 'French', code: 'fr', state: 'Stable' },
  { label: 'Polish', code: 'pl', state: 'Beta' },
  { label: 'Russian', code: 'ru', state: 'Beta' },
  { label: 'Dutch', code: 'nl', state: 'Beta' },
  { label: 'Catalan', code: 'ca', state: 'Beta' },
  { label: 'Turkish', code: 'tr', state: 'Beta' },
  { label: 'Swedish', code: 'sv', state: 'Beta' },
  { label: 'Ukrainian', code: 'uk', state: 'Beta' },
  { label: 'Norwegian', code: 'no', state: 'Beta' },
  { label: 'Finnish', code: 'fi', state: 'Beta' },
  { label: 'Slovak', code: 'sk', state: 'Beta' },
  { label: 'Greek', code: 'el', state: 'Beta' },
  { label: 'Czech', code: 'cs', state: 'Beta' },
  { label: 'Croatian', code: 'hr', state: 'Beta' },
  { label: 'Danish', code: 'da', state: 'Beta' },
  { label: 'Romanian', code: 'ro', state: 'Beta' },
  { label: 'Bulgarian', code: 'bg', state: 'Beta' },
] as const;

const SUPPORTED_MUX_LANGUAGES_VALUES = SUPPORTED_MUX_LANGUAGES.map((l) => l.code);

export type SupportedMuxLanguage = (typeof SUPPORTED_MUX_LANGUAGES_VALUES)[number];

/** .srt or .vtt file uploaded as subtitle/caption for a video */
export const TextTrackFile = z.object({
  contents: z.string(),
  type: z.string(),
  name: z.string(),
  size: z.number(),
});

/** Subtitles and captions uploaded by the user */
export const CustomTextTrack = z.object({
  file: TextTrackFile,
  name: z.string(),
  language_code: z.string(),
  closed_captions: z.boolean().default(false),
  stored_track: z.custom<Mux.Video.Track>((value) => typeof value === 'object' && value && 'id' in value).optional(),
});

export type ParsedCustomTextTrack = z.infer<typeof CustomTextTrack>;

export type StoredTextTrack = ParsedCustomTextTrack & { id: string };

export const UploadConfig = z
  .object({
    /**
     * Enable static renditions by setting this to 'standard'. Can be overwritten on a per-asset basis.
     * @see {@link https://docs.mux.com/guides/video/enable-static-mp4-renditions#why-enable-mp4-support}
     * @defaultValue 'none'
     */
    mp4_support: z.enum(['none', 'standard']).default('none'),

    /**
     * Max resolution tier can be used to control the maximum resolution_tier your asset is encoded, stored, and streamed at.
     * @see {@link https://docs.mux.com/guides/stream-videos-in-4k}
     * @defaultValue '1080p'
     */
    max_resolution_tier: z.enum(['2160p', '1440p', '1080p']).default('1080p'),

    /**
     * The video quality informs the cost, quality, and available platform features for the asset.
     * @see {@link https://docs.mux.com/guides/use-video-quality-levels}
     * @defaultValue 'plus'
     */
    video_quality: z.enum(['basic', 'plus', 'premium']).default('plus'),

    /**
     * Whether or not to use signed URLs, making the asset private
     * @see {@link https://docs.mux.com/guides/use-encoding-tiers}
     * @defaultValue 'false'
     */
    signed: z.boolean().default(false),

    autogenerated_captions_languages: z
      .array(
        z.object({
          code: z.enum(SUPPORTED_MUX_LANGUAGES_VALUES as [SupportedMuxLanguage, ...SupportedMuxLanguage[]]),
          isSourceLanguage: z.boolean().default(false),
        })
      )
      .optional(),

    custom_text_tracks: z.array(CustomTextTrack).optional(),

    upload_type: z.enum(['file', 'url']).default('file'),
  })
  .transform((v) => {
    if (v.video_quality === 'basic') {
      return {
        ...v,
        max_resolution_tier: '1080p',
        mp4_support: 'none',
      } as typeof v;
    }

    return v;
  });

export type RequestedUploadConfig = z.input<typeof UploadConfig>;
export type ParsedUploadConfig = z.infer<typeof UploadConfig>;

export const UploadData = z
  .object({ title: z.string().min(1) })
  .and(
    z.discriminatedUnion('upload_type', [
      z.object({ upload_type: z.literal('file'), file: z.custom<File>((value) => value instanceof File) }),
      z.object({ upload_type: z.literal('url'), url: z.string().url() }),
    ])
  )
  .and(UploadConfig);

export type RequestedUploadData = z.input<typeof UploadData>;

/**
 * Used by `server/controllers/mux.ts` as that doesn't receive the file from the front-end.
 * Users upload the file directly from the browser via the presigned URL generated in `parseUploadRequest`.
 */
export const UploadDataWithoutFile = z
  .object({ title: z.string().min(1) })
  .and(
    z.discriminatedUnion('upload_type', [
      z.object({ upload_type: z.literal('file') }),
      z.object({ upload_type: z.literal('url'), url: z.string().url() }),
    ])
  )
  .and(UploadConfig);

export function uploadConfigToNewAssetInput(
  config: ParsedUploadConfig,
  storedTextTracks: StoredTextTrack[] = [],
  url?: string
): Mux.Video.Assets.AssetCreateParams.Input[] | undefined {
  const inputs: Mux.Video.Assets.AssetCreateParams.Input[] = [];

  const base: Mux.Video.Assets.AssetCreateParams.Input = {};

  if (config.upload_type === 'url') {
    base.url = url;
  }

  if (config.autogenerated_captions_languages) {
    base.generated_subtitles = config.autogenerated_captions_languages.map((language) => {
      const label = SUPPORTED_MUX_LANGUAGES.find((l) => l.code === language.code)?.label || language.code;
      return {
        language_code: language.code,
        name: language.isSourceLanguage ? `${label} (CC)` : label,
        type: 'text',
        text_type: 'subtitles',
        closed_captions: true,
      };
    });
  }

  if (Object.keys(base).length > 0) {
    inputs.push(base);
  }

  if (storedTextTracks.length > 0) {
    inputs.push(...storedTextTracks.map(storedTextTrackToMuxTrack));
  }

  return inputs.length > 0 ? inputs : undefined;
}
